
#include <Arduino.h>
#ifdef M5UNIFIED
#include <M5Unified.h>
#endif
#include "Esp.h"
#include "FlowSensor.h"
#include "FunctionalInterrupt.h"
#include "NimBLEAddress.h"
#include "QuadratureDecoder.h"
#include "Ticker.h"
#include "beacon.h"
#include "defs.h"

#ifdef LVGL_UI
#include "lv_setup.h"
#include "ui/ui.h"
#endif

#define T2OK(x) ((x) ? "OK" : "FAILED")

FlowSensor flow_sensor;
QuadratureDecoder qdecoder;

uint8_t flowsensor_A = PIN_FLOWSENSOR_A;
uint8_t flowsensor_B = PIN_FLOWSENSOR_B;
Ticker sampler, battery, sensor, idle;

void sensor_update(bool force);

static mfdReport_t manufacturer_data;
void sensor_update(bool force);

static int32_t track_count;
static uint32_t track_now;
static float max_rate;

#ifdef LVGL_UI
void clearCountPressed(lv_event_t *e) {
#ifdef QUADRATURE_DECODER
  qdecoder.reset();
#endif
#ifdef FLOWSENSOR
  flow_sensor.reset();
#endif
  track_count = 0;
  track_now = micros();
  max_rate = 0;
  sensor_update(true);
}
#endif

void setup() {

  // delay(3000);

#ifdef M5UNIFIED
  auto cfg = M5.config();
  M5.begin(cfg);
#else
  Serial.begin(115200);
#endif

#ifdef LVGL_UI
  lv_begin(); // Initialize LVGL for the Core2 screen
  ui_init();  // Initialize UI generated by Square Line
  ui_set_inital_values();
#endif
  ESP_LOGI(__FILE__, "total PSRAM=%u free PSRAM=%u mfd=%u\n",
           ESP.getPsramSize(), ESP.getFreePsram(), sizeof(mfdReport_t));
  ESP_LOGI(__FILE__, "flowsensor_A %u %s\n", flowsensor_A,
           T2OK(digitalPinIsValid(flowsensor_A)));
  ESP_LOGI(__FILE__, "flowsensor_B %u: %s\n", flowsensor_B,
           T2OK(digitalPinIsValid(flowsensor_B)));
#ifdef FLOWSENSOR
  flow_sensor.begin(flowsensor_A);
  ESP_LOGI(__FILE__, "flowsensor enabled: %s\n", T2OK(flow_sensor.enable()));
#endif

#ifdef QUADRATURE_DECODER
  qdecoder.begin(PIN_FLOWSENSOR_A, PIN_FLOWSENSOR_B, 1, 0);
  ESP_LOGI(__FILE__, "A/B sensor enabled: %s\n", T2OK(qdecoder.enable()));
#endif

  manufacturer_data.mfidLow = MANUFACTURER_ID & 0x00ff;
  manufacturer_data.mfidHigh = (MANUFACTURER_ID >> 8) & 0x00ff;
#ifdef QUADRATURE_DECODER
  manufacturer_data.flags |= FLAG_QUADRATURE;
#endif
  M5.update();

#ifdef M5UNIFIED
  manufacturer_data.batteryLevel = M5.Power.getBatteryLevel();
#endif
  const uint8_t *na = (const uint8_t *)beacon_setup().c_str();
  uint8_t *ap = manufacturer_data.address;
  *ap++ = na[5];
  *ap++ = na[4];
  *ap++ = na[3];
  *ap++ = na[2];
  *ap++ = na[1];
  *ap++ = na[0];
  sensor.attach_ms(UPDATE_MS, []() { sensor_update(false); });
  idle.attach_ms(IDLE_UPDATE_MS, []() {
#ifdef M5UNIFIED
    M5.update();
    manufacturer_data.batteryLevel = M5.Power.getBatteryLevel();
    manufacturer_data.flags &= ~CHARGE_MASK;

    switch (M5.Power.isCharging()) {
    case m5::Power_Class::is_discharging:
      manufacturer_data.flags |= FLAG_DISCHARGING;
      break;
    case m5::Power_Class::is_charging:
      manufacturer_data.flags |= FLAG_CHARGING;
      break;
    case m5::Power_Class::charge_unknown:
      manufacturer_data.flags |= FLAG_CHARGE_UNKNOWN;
      break;
    }
#endif
    sensor_update(true);
  });
}

void loop() {
#ifdef LVGL_UI
  lv_handler(); // Update UI
  // update_time(); // Update time and date on UI
#endif
  delay(1);
}

void sensor_update(bool force) {

#ifdef QUADRATURE_DECODER
  qsensor_report_t report;
  qdecoder.getReport(report);

  if ((report.count != track_count) || force) {
    uint32_t now = micros();

    float delta = (float)(report.count - track_count);
    float rate = delta * 1.e6f / (now - track_now);
    if (rate > max_rate) {
      max_rate = rate;
    }
    track_count = report.count;
    track_now = now;

    manufacturer_data.rate = rate * 10;
    manufacturer_data.count = report.count;
    manufacturer_data.last_change = report.last_change;
    beacon_update_manufacturer_data((uint8_t *)&manufacturer_data,
                                    sizeof((manufacturer_data)));
  }
  // ESP_LOGI(__FILE__, "count: %d rate: %d max_rate %f force %d\n",
  //          manufacturer_data.count, manufacturer_data.rate, max_rate, force);
  ui_update_values(manufacturer_data, max_rate);
#endif
#ifdef FLOWSENSOR
  flowsensor_report_t report;

  if (flow_sensor.flowDetected() || force) {
    flow_sensor.getReport(report);
    // ESP_LOGI(__FILE__, "IRQs: %u  count: %u bounces: %u force %d\n",
    //          report.irqs, report.count, report.bounces, force);

    uint32_t now = micros();

    float delta = (float)(report.count - track_count);
    float rate = delta * 1.e6f / (now - track_now);
    if (rate > max_rate) {
      max_rate = rate;
    }
    track_count = report.count;
    track_now = now;

    manufacturer_data.rate = rate * 10;
    manufacturer_data.count = report.count;
    manufacturer_data.last_change = report.last_edge;
    beacon_update_manufacturer_data((uint8_t *)&manufacturer_data,
                                    sizeof((manufacturer_data)));
  }
  ui_update_values(manufacturer_data, max_rate);

#endif
}
